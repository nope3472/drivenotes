{
    "sourceFile": "lib/notes_controller.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 22,
            "patches": [
                {
                    "date": 1744897162364,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1744897327142,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,40 @@\n-flutter pub add flutter_riverpod google_sign_in googleapis googleapis_auth http flutter_secure_storage dio go_router json_serializable firebase_core firebase_auth\r\n+import 'package:flutter_riverpod/flutter_riverpod.dart';\r\n+\r\n+\r\n+/// Loads & manages the list of notes in Drive.\r\n+final notesControllerProvider =\r\n+    AsyncNotifierProvider<NotesController, List<NoteModel>>(NotesController.new);\r\n+\r\n+class NotesController extends AsyncNotifier<List<NoteModel>> {\r\n+  @override\r\n+  Future<List<NoteModel>> build() async {\r\n+    // 1. Ensure folder exists\r\n+    await DriveService.instance.ensureFolderExists();\r\n+    // 2. List .txt files\r\n+    final files = await DriveService.instance.listRawFiles();\r\n+    // 3. Fetch contents & map to NoteModel\r\n+    final notes = <NoteModel>[];\r\n+    for (var f in files) {\r\n+      final content = await DriveService.instance.fetchContent(f.id!);\r\n+      notes.add(NoteModel.fromDrive(\r\n+        id: f.id!,\r\n+        name: f.name!,\r\n+        content: content,\r\n+      ));\r\n+    }\r\n+    return notes;\r\n+  }\r\n+\r\n+  /// Deletes a note and refreshes the list\r\n+  Future<void> delete(String fileId) async {\r\n+    state = const AsyncValue.loading();\r\n+    try {\r\n+      await DriveService.instance.deleteNote(fileId);\r\n+      // remove locally\r\n+      final remaining = state.value!.where((n) => n.id != fileId).toList();\r\n+      state = AsyncValue.data(remaining);\r\n+    } catch (e, st) {\r\n+      state = AsyncValue.error(e, st);\r\n+    }\r\n+  }\r\n+}\r\n"
                },
                {
                    "date": 1744897358542,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,10 +1,13 @@\n+import 'package:drivenotes/features/notes/domain/models/note_model.dart';\r\n import 'package:flutter_riverpod/flutter_riverpod.dart';\r\n+import 'package:drivenotes/features/notes/data/drive_service.dart';\r\n \r\n-\r\n /// Loads & manages the list of notes in Drive.\r\n final notesControllerProvider =\r\n-    AsyncNotifierProvider<NotesController, List<NoteModel>>(NotesController.new);\r\n+    AsyncNotifierProvider<NotesController, List<NoteModel>>(\r\n+      NotesController.new,\r\n+    );\r\n \r\n class NotesController extends AsyncNotifier<List<NoteModel>> {\r\n   @override\r\n   Future<List<NoteModel>> build() async {\r\n@@ -15,13 +18,11 @@\n     // 3. Fetch contents & map to NoteModel\r\n     final notes = <NoteModel>[];\r\n     for (var f in files) {\r\n       final content = await DriveService.instance.fetchContent(f.id!);\r\n-      notes.add(NoteModel.fromDrive(\r\n-        id: f.id!,\r\n-        name: f.name!,\r\n-        content: content,\r\n-      ));\r\n+      notes.add(\r\n+        NoteModel.fromDrive(id: f.id!, name: f.name!, content: content),\r\n+      );\r\n     }\r\n     return notes;\r\n   }\r\n \r\n"
                },
                {
                    "date": 1744897638982,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,40 +1,30 @@\n-import 'package:drivenotes/features/notes/domain/models/note_model.dart';\r\n import 'package:flutter_riverpod/flutter_riverpod.dart';\r\n-import 'package:drivenotes/features/notes/data/drive_service.dart';\r\n+import '../../data/note_model.dart';\r\n+import '../../../core/services/drive_service.dart';\r\n \r\n-/// Loads & manages the list of notes in Drive.\r\n final notesControllerProvider =\r\n-    AsyncNotifierProvider<NotesController, List<NoteModel>>(\r\n-      NotesController.new,\r\n-    );\r\n+    AsyncNotifierProvider<NotesController, List<NoteModel>>(NotesController.new);\r\n \r\n class NotesController extends AsyncNotifier<List<NoteModel>> {\r\n   @override\r\n   Future<List<NoteModel>> build() async {\r\n-    // 1. Ensure folder exists\r\n     await DriveService.instance.ensureFolderExists();\r\n-    // 2. List .txt files\r\n     final files = await DriveService.instance.listRawFiles();\r\n-    // 3. Fetch contents & map to NoteModel\r\n-    final notes = <NoteModel>[];\r\n+    final out = <NoteModel>[];\r\n     for (var f in files) {\r\n-      final content = await DriveService.instance.fetchContent(f.id!);\r\n-      notes.add(\r\n-        NoteModel.fromDrive(id: f.id!, name: f.name!, content: content),\r\n-      );\r\n+      final c = await DriveService.instance.fetchContent(f.id!);\r\n+      out.add(NoteModel.fromDrive(id: f.id!, name: f.name!, content: c));\r\n     }\r\n-    return notes;\r\n+    return out;\r\n   }\r\n \r\n-  /// Deletes a note and refreshes the list\r\n-  Future<void> delete(String fileId) async {\r\n+  Future<void> delete(String id) async {\r\n     state = const AsyncValue.loading();\r\n     try {\r\n-      await DriveService.instance.deleteNote(fileId);\r\n-      // remove locally\r\n-      final remaining = state.value!.where((n) => n.id != fileId).toList();\r\n-      state = AsyncValue.data(remaining);\r\n+      await DriveService.instance.deleteNote(id);\r\n+      final remain = state.value!.where((n) => n.id != id).toList();\r\n+      state = AsyncValue.data(remain);\r\n     } catch (e, st) {\r\n       state = AsyncValue.error(e, st);\r\n     }\r\n   }\r\n"
                },
                {
                    "date": 1744897794963,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,7 @@\n import 'package:flutter_riverpod/flutter_riverpod.dart';\r\n-import '../../data/note_model.dart';\r\n-import '../../../core/services/drive_service.dart';\r\n \r\n+\r\n final notesControllerProvider =\r\n     AsyncNotifierProvider<NotesController, List<NoteModel>>(NotesController.new);\r\n \r\n class NotesController extends AsyncNotifier<List<NoteModel>> {\r\n"
                },
                {
                    "date": 1744897801794,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+import 'package:drivenotes/features/notes/data/drive_service.dart';\r\n+import 'package:drivenotes/features/notes/domain/models/note_model.dart';\r\n import 'package:flutter_riverpod/flutter_riverpod.dart';\r\n \r\n \r\n final notesControllerProvider =\r\n"
                },
                {
                    "date": 1744898977441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,32 +1,44 @@\n import 'package:drivenotes/features/notes/data/drive_service.dart';\r\n import 'package:drivenotes/features/notes/domain/models/note_model.dart';\r\n+import 'package:flutter/foundation.dart';\r\n import 'package:flutter_riverpod/flutter_riverpod.dart';\r\n \r\n-\r\n final notesControllerProvider =\r\n-    AsyncNotifierProvider<NotesController, List<NoteModel>>(NotesController.new);\r\n+    AsyncNotifierProvider<NotesController, List<NoteModel>>(\r\n+      NotesController.new,\r\n+    );\r\n \r\n class NotesController extends AsyncNotifier<List<NoteModel>> {\r\n   @override\r\n   Future<List<NoteModel>> build() async {\r\n+    debugPrint('NotesController: Loading notes...');\r\n     await DriveService.instance.ensureFolderExists();\r\n+\r\n     final files = await DriveService.instance.listRawFiles();\r\n+    debugPrint('NotesController: Found ${files.length} files');\r\n+\r\n     final out = <NoteModel>[];\r\n     for (var f in files) {\r\n-      final c = await DriveService.instance.fetchContent(f.id!);\r\n-      out.add(NoteModel.fromDrive(id: f.id!, name: f.name!, content: c));\r\n+      debugPrint('NotesController: Loading content for file ${f.name}');\r\n+      final content = await DriveService.instance.fetchContent(f.id);\r\n+      out.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\r\n     }\r\n+\r\n+    debugPrint('NotesController: Loaded ${out.length} notes');\r\n     return out;\r\n   }\r\n \r\n   Future<void> delete(String id) async {\r\n+    debugPrint('NotesController: Deleting note $id');\r\n     state = const AsyncValue.loading();\r\n     try {\r\n       await DriveService.instance.deleteNote(id);\r\n       final remain = state.value!.where((n) => n.id != id).toList();\r\n       state = AsyncValue.data(remain);\r\n+      debugPrint('NotesController: Note deleted successfully');\r\n     } catch (e, st) {\r\n+      debugPrint('NotesController: Error deleting note - $e');\r\n       state = AsyncValue.error(e, st);\r\n     }\r\n   }\r\n }\r\n"
                },
                {
                    "date": 1744899223246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,9 +11,8 @@\n class NotesController extends AsyncNotifier<List<NoteModel>> {\r\n   @override\r\n   Future<List<NoteModel>> build() async {\r\n     debugPrint('NotesController: Loading notes...');\r\n-    await DriveService.instance.ensureFolderExists();\r\n \r\n     final files = await DriveService.instance.listRawFiles();\r\n     debugPrint('NotesController: Found ${files.length} files');\r\n \r\n"
                },
                {
                    "date": 1744914416101,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n import 'package:drivenotes/features/notes/data/drive_service.dart';\r\n import 'package:drivenotes/features/notes/domain/models/note_model.dart';\r\n import 'package:flutter/foundation.dart';\r\n import 'package:flutter_riverpod/flutter_riverpod.dart';\r\n+import 'dart:convert';\r\n \r\n final notesControllerProvider =\r\n     AsyncNotifierProvider<NotesController, List<NoteModel>>(\r\n       NotesController.new,\r\n@@ -17,11 +18,27 @@\n     debugPrint('NotesController: Found ${files.length} files');\r\n \r\n     final out = <NoteModel>[];\r\n     for (var f in files) {\r\n-      debugPrint('NotesController: Loading content for file ${f.name}');\r\n-      final content = await DriveService.instance.fetchContent(f.id);\r\n-      out.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\r\n+      if (f.id != null && f.name != null) {\r\n+        debugPrint('NotesController: Loading content for file ${f.name}');\r\n+        try {\r\n+          final content = await DriveService.instance.fetchContent(f.id!);\r\n+          final contentMap = json.decode(content) as Map<String, dynamic>;\r\n+          out.add(\r\n+            NoteModel.fromDrive(\r\n+              id: f.id!,\r\n+              name: f.name!,\r\n+              content: contentMap['content'] as String? ?? '',\r\n+              fontFamily: contentMap['fontFamily'] as String? ?? 'Roboto',\r\n+            ),\r\n+          );\r\n+        } catch (e) {\r\n+          debugPrint('NotesController: Error loading note ${f.name} - $e');\r\n+          // Skip this note if there's an error\r\n+          continue;\r\n+        }\r\n+      }\r\n     }\r\n \r\n     debugPrint('NotesController: Loaded ${out.length} notes');\r\n     return out;\r\n"
                },
                {
                    "date": 1744914897520,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,17 +22,27 @@\n       if (f.id != null && f.name != null) {\r\n         debugPrint('NotesController: Loading content for file ${f.name}');\r\n         try {\r\n           final content = await DriveService.instance.fetchContent(f.id!);\r\n-          final contentMap = json.decode(content) as Map<String, dynamic>;\r\n-          out.add(\r\n-            NoteModel.fromDrive(\r\n-              id: f.id!,\r\n-              name: f.name!,\r\n-              content: contentMap['content'] as String? ?? '',\r\n-              fontFamily: contentMap['fontFamily'] as String? ?? 'Roboto',\r\n-            ),\r\n-          );\r\n+\r\n+          // Try to parse as JSON first (new format)\r\n+          try {\r\n+            final contentMap = json.decode(content) as Map<String, dynamic>;\r\n+            out.add(\r\n+              NoteModel.fromDrive(\r\n+                id: f.id!,\r\n+                name: f.name!,\r\n+                content: contentMap['content'] as String? ?? '',\r\n+                fontFamily: contentMap['fontFamily'] as String? ?? 'Roboto',\r\n+              ),\r\n+            );\r\n+          } catch (e) {\r\n+            // If not JSON, treat as plain text (old format)\r\n+            debugPrint('NotesController: Converting plain text to note format');\r\n+            out.add(\r\n+              NoteModel.fromDrive(id: f.id!, name: f.name!, content: content),\r\n+            );\r\n+          }\r\n         } catch (e) {\r\n           debugPrint('NotesController: Error loading note ${f.name} - $e');\r\n           // Skip this note if there's an error\r\n           continue;\r\n"
                },
                {
                    "date": 1744915270577,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,70 +1,43 @@\n-import 'package:drivenotes/features/notes/data/drive_service.dart';\r\n-import 'package:drivenotes/features/notes/domain/models/note_model.dart';\r\n-import 'package:flutter/foundation.dart';\r\n-import 'package:flutter_riverpod/flutter_riverpod.dart';\r\n-import 'dart:convert';\r\n-\r\n-final notesControllerProvider =\r\n-    AsyncNotifierProvider<NotesController, List<NoteModel>>(\r\n-      NotesController.new,\r\n-    );\r\n-\r\n-class NotesController extends AsyncNotifier<List<NoteModel>> {\r\n-  @override\r\n-  Future<List<NoteModel>> build() async {\r\n-    debugPrint('NotesController: Loading notes...');\r\n-\r\n-    final files = await DriveService.instance.listRawFiles();\r\n-    debugPrint('NotesController: Found ${files.length} files');\r\n-\r\n-    final out = <NoteModel>[];\r\n-    for (var f in files) {\r\n-      if (f.id != null && f.name != null) {\r\n-        debugPrint('NotesController: Loading content for file ${f.name}');\r\n-        try {\r\n-          final content = await DriveService.instance.fetchContent(f.id!);\r\n-\r\n-          // Try to parse as JSON first (new format)\r\n-          try {\r\n-            final contentMap = json.decode(content) as Map<String, dynamic>;\r\n-            out.add(\r\n-              NoteModel.fromDrive(\r\n-                id: f.id!,\r\n-                name: f.name!,\r\n-                content: contentMap['content'] as String? ?? '',\r\n-                fontFamily: contentMap['fontFamily'] as String? ?? 'Roboto',\r\n-              ),\r\n-            );\r\n-          } catch (e) {\r\n-            // If not JSON, treat as plain text (old format)\r\n-            debugPrint('NotesController: Converting plain text to note format');\r\n-            out.add(\r\n-              NoteModel.fromDrive(id: f.id!, name: f.name!, content: content),\r\n-            );\r\n-          }\r\n-        } catch (e) {\r\n-          debugPrint('NotesController: Error loading note ${f.name} - $e');\r\n-          // Skip this note if there's an error\r\n-          continue;\r\n-        }\r\n-      }\r\n-    }\r\n-\r\n-    debugPrint('NotesController: Loaded ${out.length} notes');\r\n-    return out;\r\n-  }\r\n-\r\n-  Future<void> delete(String id) async {\r\n-    debugPrint('NotesController: Deleting note $id');\r\n-    state = const AsyncValue.loading();\r\n-    try {\r\n-      await DriveService.instance.deleteNote(id);\r\n-      final remain = state.value!.where((n) => n.id != id).toList();\r\n-      state = AsyncValue.data(remain);\r\n-      debugPrint('NotesController: Note deleted successfully');\r\n-    } catch (e, st) {\r\n-      debugPrint('NotesController: Error deleting note - $e');\r\n-      state = AsyncValue.error(e, st);\r\n-    }\r\n-  }\r\n-}\r\n+import 'package:drivenotes/features/notes/data/drive_service.dart';\n+import 'package:drivenotes/features/notes/domain/models/note_model.dart';\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter_riverpod/flutter_riverpod.dart';\n+\n+final notesControllerProvider =\n+    AsyncNotifierProvider<NotesController, List<NoteModel>>(\n+      NotesController.new,\n+    );\n+\n+class NotesController extends AsyncNotifier<List<NoteModel>> {\n+  @override\n+  Future<List<NoteModel>> build() async {\n+    debugPrint('NotesController: Loading notes...');\n+\n+    final files = await DriveService.instance.listRawFiles();\n+    debugPrint('NotesController: Found ${files.length} files');\n+\n+    final out = <NoteModel>[];\n+    for (var f in files) {\n+      debugPrint('NotesController: Loading content for file ${f.name}');\n+      final content = await DriveService.instance.fetchContent(f.id);\n+      out.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\n+    }\n+\n+    debugPrint('NotesController: Loaded ${out.length} notes');\n+    return out;\n+  }\n+\n+  Future<void> delete(String id) async {\n+    debugPrint('NotesController: Deleting note $id');\n+    state = const AsyncValue.loading();\n+    try {\n+      await DriveService.instance.deleteNote(id);\n+      final remain = state.value!.where((n) => n.id != id).toList();\n+      state = AsyncValue.data(remain);\n+      debugPrint('NotesController: Note deleted successfully');\n+    } catch (e, st) {\n+      debugPrint('NotesController: Error deleting note - $e');\n+      state = AsyncValue.error(e, st);\n+    }\n+  }\n+}\n"
                },
                {
                    "date": 1744917551349,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n import 'package:drivenotes/features/notes/data/drive_service.dart';\n import 'package:drivenotes/features/notes/domain/models/note_model.dart';\n+import 'package:drivenotes/features/notes/presentation/providers/drive_service_provider.dart';\n import 'package:flutter/foundation.dart';\n import 'package:flutter_riverpod/flutter_riverpod.dart';\n \n final notesControllerProvider =\n@@ -12,15 +13,16 @@\n   @override\n   Future<List<NoteModel>> build() async {\n     debugPrint('NotesController: Loading notes...');\n \n-    final files = await DriveService.instance.listRawFiles();\n+    final driveService = ref.watch(driveServiceProvider);\n+    final files = await driveService.listRawFiles();\n     debugPrint('NotesController: Found ${files.length} files');\n \n     final out = <NoteModel>[];\n     for (var f in files) {\n       debugPrint('NotesController: Loading content for file ${f.name}');\n-      final content = await DriveService.instance.fetchContent(f.id);\n+      final content = await driveService.fetchContent(f.id);\n       out.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\n     }\n \n     debugPrint('NotesController: Loaded ${out.length} notes');\n@@ -30,9 +32,10 @@\n   Future<void> delete(String id) async {\n     debugPrint('NotesController: Deleting note $id');\n     state = const AsyncValue.loading();\n     try {\n-      await DriveService.instance.deleteNote(id);\n+      final driveService = ref.read(driveServiceProvider);\n+      await driveService.deleteNote(id);\n       final remain = state.value!.where((n) => n.id != id).toList();\n       state = AsyncValue.data(remain);\n       debugPrint('NotesController: Note deleted successfully');\n     } catch (e, st) {\n"
                },
                {
                    "date": 1744917598796,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,6 @@\n import 'package:drivenotes/features/notes/data/drive_service.dart';\n import 'package:drivenotes/features/notes/domain/models/note_model.dart';\n-import 'package:drivenotes/features/notes/presentation/providers/drive_service_provider.dart';\n import 'package:flutter/foundation.dart';\n import 'package:flutter_riverpod/flutter_riverpod.dart';\n \n final notesControllerProvider =\n@@ -13,16 +12,15 @@\n   @override\n   Future<List<NoteModel>> build() async {\n     debugPrint('NotesController: Loading notes...');\n \n-    final driveService = ref.watch(driveServiceProvider);\n-    final files = await driveService.listRawFiles();\n+    final files = await DriveService.instance.listRawFiles();\n     debugPrint('NotesController: Found ${files.length} files');\n \n     final out = <NoteModel>[];\n     for (var f in files) {\n       debugPrint('NotesController: Loading content for file ${f.name}');\n-      final content = await driveService.fetchContent(f.id);\n+      final content = await DriveService.instance.fetchContent(f.id);\n       out.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\n     }\n \n     debugPrint('NotesController: Loaded ${out.length} notes');\n@@ -32,10 +30,9 @@\n   Future<void> delete(String id) async {\n     debugPrint('NotesController: Deleting note $id');\n     state = const AsyncValue.loading();\n     try {\n-      final driveService = ref.read(driveServiceProvider);\n-      await driveService.deleteNote(id);\n+      await DriveService.instance.deleteNote(id);\n       final remain = state.value!.where((n) => n.id != id).toList();\n       state = AsyncValue.data(remain);\n       debugPrint('NotesController: Note deleted successfully');\n     } catch (e, st) {\n"
                },
                {
                    "date": 1744971855244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,8 +1,9 @@\n import 'package:drivenotes/features/notes/data/drive_service.dart';\n import 'package:drivenotes/features/notes/domain/models/note_model.dart';\n import 'package:flutter/foundation.dart';\n import 'package:flutter_riverpod/flutter_riverpod.dart';\n+import 'package:drivenotes/features/notes/data/local_database.dart';\n \n final notesControllerProvider =\n     AsyncNotifierProvider<NotesController, List<NoteModel>>(\n       NotesController.new,\n@@ -11,31 +12,57 @@\n class NotesController extends AsyncNotifier<List<NoteModel>> {\n   @override\n   Future<List<NoteModel>> build() async {\n     debugPrint('NotesController: Loading notes...');\n+    \n+    try {\n+      // Try to get notes from Drive first\n+      final files = await DriveService.instance.listRawFiles();\n+      debugPrint('NotesController: Found ${files.length} files in Drive');\n \n-    final files = await DriveService.instance.listRawFiles();\n-    debugPrint('NotesController: Found ${files.length} files');\n-\n-    final out = <NoteModel>[];\n-    for (var f in files) {\n-      debugPrint('NotesController: Loading content for file ${f.name}');\n-      final content = await DriveService.instance.fetchContent(f.id);\n-      out.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\n+      final out = <NoteModel>[];\n+      for (var f in files) {\n+        try {\n+          debugPrint('NotesController: Loading content for file ${f.name}');\n+          final content = await DriveService.instance.fetchContent(f.id);\n+          out.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\n+        } catch (e) {\n+          debugPrint('NotesController: Error loading note ${f.name} - $e');\n+          continue;\n+        }\n+      }\n+      \n+      debugPrint('NotesController: Loaded ${out.length} notes from Drive');\n+      return out;\n+    } catch (e) {\n+      debugPrint('NotesController: Error loading from Drive, falling back to local - $e');\n+      // If Drive access fails, fall back to local database\n+      final localNotes = await LocalDatabase.instance.getAllNotes();\n+      debugPrint('NotesController: Loaded ${localNotes.length} notes from local DB');\n+      return localNotes;\n     }\n-\n-    debugPrint('NotesController: Loaded ${out.length} notes');\n-    return out;\n   }\n \n   Future<void> delete(String id) async {\n     debugPrint('NotesController: Deleting note $id');\n     state = const AsyncValue.loading();\n     try {\n-      await DriveService.instance.deleteNote(id);\n+      // Delete from Drive first\n+      try {\n+        await DriveService.instance.deleteNote(id);\n+        debugPrint('NotesController: Deleted from Drive successfully');\n+      } catch (e) {\n+        debugPrint('NotesController: Error deleting from Drive - $e');\n+        // Continue with local deletion even if Drive fails\n+      }\n+\n+      // Always delete locally\n+      await LocalDatabase.instance.deleteNote(id);\n+      debugPrint('NotesController: Deleted from local DB successfully');\n+\n+      // Update state\n       final remain = state.value!.where((n) => n.id != id).toList();\n       state = AsyncValue.data(remain);\n-      debugPrint('NotesController: Note deleted successfully');\n     } catch (e, st) {\n       debugPrint('NotesController: Error deleting note - $e');\n       state = AsyncValue.error(e, st);\n     }\n"
                },
                {
                    "date": 1744971862191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,9 +12,9 @@\n class NotesController extends AsyncNotifier<List<NoteModel>> {\n   @override\n   Future<List<NoteModel>> build() async {\n     debugPrint('NotesController: Loading notes...');\n-    \n+\n     try {\n       // Try to get notes from Drive first\n       final files = await DriveService.instance.listRawFiles();\n       debugPrint('NotesController: Found ${files.length} files in Drive');\n@@ -23,22 +23,28 @@\n       for (var f in files) {\n         try {\n           debugPrint('NotesController: Loading content for file ${f.name}');\n           final content = await DriveService.instance.fetchContent(f.id);\n-          out.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\n+          out.add(\n+            NoteModel.fromDrive(id: f.id, name: f.name, content: content),\n+          );\n         } catch (e) {\n           debugPrint('NotesController: Error loading note ${f.name} - $e');\n           continue;\n         }\n       }\n-      \n+\n       debugPrint('NotesController: Loaded ${out.length} notes from Drive');\n       return out;\n     } catch (e) {\n-      debugPrint('NotesController: Error loading from Drive, falling back to local - $e');\n+      debugPrint(\n+        'NotesController: Error loading from Drive, falling back to local - $e',\n+      );\n       // If Drive access fails, fall back to local database\n       final localNotes = await LocalDatabase.instance.getAllNotes();\n-      debugPrint('NotesController: Loaded ${localNotes.length} notes from local DB');\n+      debugPrint(\n+        'NotesController: Loaded ${localNotes.length} notes from local DB',\n+      );\n       return localNotes;\n     }\n   }\n \n"
                },
                {
                    "date": 1744972110002,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,39 +12,48 @@\n class NotesController extends AsyncNotifier<List<NoteModel>> {\n   @override\n   Future<List<NoteModel>> build() async {\n     debugPrint('NotesController: Loading notes...');\n-\n+    \n+    // Always get local notes first\n+    final localNotes = await LocalDatabase.instance.getAllNotes();\n+    debugPrint('NotesController: Found ${localNotes.length} local notes');\n+    \n     try {\n-      // Try to get notes from Drive first\n-      final files = await DriveService.instance.listRawFiles();\n-      debugPrint('NotesController: Found ${files.length} files in Drive');\n+      // Try to get notes from Drive\n+      final driveFiles = await DriveService.instance.listRawFiles();\n+      debugPrint('NotesController: Found ${driveFiles.length} files in Drive');\n \n-      final out = <NoteModel>[];\n-      for (var f in files) {\n+      final driveNotes = <NoteModel>[];\n+      for (var f in driveFiles) {\n         try {\n           debugPrint('NotesController: Loading content for file ${f.name}');\n           final content = await DriveService.instance.fetchContent(f.id);\n-          out.add(\n-            NoteModel.fromDrive(id: f.id, name: f.name, content: content),\n-          );\n+          driveNotes.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\n         } catch (e) {\n           debugPrint('NotesController: Error loading note ${f.name} - $e');\n           continue;\n         }\n       }\n-\n-      debugPrint('NotesController: Loaded ${out.length} notes from Drive');\n-      return out;\n+      \n+      // Merge notes, prioritizing Drive versions\n+      final mergedNotes = <NoteModel>[];\n+      final localNoteMap = {for (var note in localNotes) note.id: note};\n+      \n+      // Add all Drive notes first\n+      for (var driveNote in driveNotes) {\n+        mergedNotes.add(driveNote);\n+        // Remove from local map to track which notes are only local\n+        localNoteMap.remove(driveNote.id);\n+      }\n+      \n+      // Add remaining local notes that aren't in Drive\n+      mergedNotes.addAll(localNoteMap.values);\n+      \n+      debugPrint('NotesController: Merged ${mergedNotes.length} notes (${driveNotes.length} from Drive, ${localNoteMap.length} local-only)');\n+      return mergedNotes;\n     } catch (e) {\n-      debugPrint(\n-        'NotesController: Error loading from Drive, falling back to local - $e',\n-      );\n-      // If Drive access fails, fall back to local database\n-      final localNotes = await LocalDatabase.instance.getAllNotes();\n-      debugPrint(\n-        'NotesController: Loaded ${localNotes.length} notes from local DB',\n-      );\n+      debugPrint('NotesController: Error loading from Drive, using local notes - $e');\n       return localNotes;\n     }\n   }\n \n"
                },
                {
                    "date": 1744972116356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,13 +12,13 @@\n class NotesController extends AsyncNotifier<List<NoteModel>> {\n   @override\n   Future<List<NoteModel>> build() async {\n     debugPrint('NotesController: Loading notes...');\n-    \n+\n     // Always get local notes first\n     final localNotes = await LocalDatabase.instance.getAllNotes();\n     debugPrint('NotesController: Found ${localNotes.length} local notes');\n-    \n+\n     try {\n       // Try to get notes from Drive\n       final driveFiles = await DriveService.instance.listRawFiles();\n       debugPrint('NotesController: Found ${driveFiles.length} files in Drive');\n@@ -27,33 +27,39 @@\n       for (var f in driveFiles) {\n         try {\n           debugPrint('NotesController: Loading content for file ${f.name}');\n           final content = await DriveService.instance.fetchContent(f.id);\n-          driveNotes.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\n+          driveNotes.add(\n+            NoteModel.fromDrive(id: f.id, name: f.name, content: content),\n+          );\n         } catch (e) {\n           debugPrint('NotesController: Error loading note ${f.name} - $e');\n           continue;\n         }\n       }\n-      \n+\n       // Merge notes, prioritizing Drive versions\n       final mergedNotes = <NoteModel>[];\n       final localNoteMap = {for (var note in localNotes) note.id: note};\n-      \n+\n       // Add all Drive notes first\n       for (var driveNote in driveNotes) {\n         mergedNotes.add(driveNote);\n         // Remove from local map to track which notes are only local\n         localNoteMap.remove(driveNote.id);\n       }\n-      \n+\n       // Add remaining local notes that aren't in Drive\n       mergedNotes.addAll(localNoteMap.values);\n-      \n-      debugPrint('NotesController: Merged ${mergedNotes.length} notes (${driveNotes.length} from Drive, ${localNoteMap.length} local-only)');\n+\n+      debugPrint(\n+        'NotesController: Merged ${mergedNotes.length} notes (${driveNotes.length} from Drive, ${localNoteMap.length} local-only)',\n+      );\n       return mergedNotes;\n     } catch (e) {\n-      debugPrint('NotesController: Error loading from Drive, using local notes - $e');\n+      debugPrint(\n+        'NotesController: Error loading from Drive, using local notes - $e',\n+      );\n       return localNotes;\n     }\n   }\n \n"
                },
                {
                    "date": 1744972198433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -36,8 +36,25 @@\n           continue;\n         }\n       }\n \n+      // Upload unsynced local notes to Drive\n+      final unsyncedNotes = localNotes.where((note) => !note.isSynced).toList();\n+      if (unsyncedNotes.isNotEmpty) {\n+        debugPrint('NotesController: Found ${unsyncedNotes.length} unsynced notes to upload');\n+        for (var note in unsyncedNotes) {\n+          try {\n+            debugPrint('NotesController: Uploading unsynced note: ${note.title}');\n+            final driveId = await DriveService.instance.createNote(note.title, note.content);\n+            await LocalDatabase.instance.markNoteAsSynced(note.id, driveId);\n+            debugPrint('NotesController: Successfully uploaded and synced note: ${note.title}');\n+          } catch (e) {\n+            debugPrint('NotesController: Error uploading note ${note.title} - $e');\n+            continue;\n+          }\n+        }\n+      }\n+\n       // Merge notes, prioritizing Drive versions\n       final mergedNotes = <NoteModel>[];\n       final localNoteMap = {for (var note in localNotes) note.id: note};\n \n"
                },
                {
                    "date": 1744972204245,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,17 +39,34 @@\n \n       // Upload unsynced local notes to Drive\n       final unsyncedNotes = localNotes.where((note) => !note.isSynced).toList();\n       if (unsyncedNotes.isNotEmpty) {\n-        debugPrint('NotesController: Found ${unsyncedNotes.length} unsynced notes to upload');\n+        debugPrint(\n+          'NotesController: Found ${unsyncedNotes.length} unsynced notes to upload',\n+        );\n         for (var note in unsyncedNotes) {\n           try {\n-            debugPrint('NotesController: Uploading unsynced note: ${note.title}');\n-            final driveId = await DriveService.instance.createNote(note.title, note.content);\n-            await LocalDatabase.instance.markNoteAsSynced(note.id, driveId);\n-            debugPrint('NotesController: Successfully uploaded and synced note: ${note.title}');\n+            debugPrint(\n+              'NotesController: Uploading unsynced note: ${note.title}',\n+            );\n+            final driveId = await DriveService.instance.createNote(\n+              note.title,\n+              note.content,\n+            );\n+            if (driveId != null) {\n+              await LocalDatabase.instance.markNoteAsSynced(note.id, driveId);\n+              debugPrint(\n+                'NotesController: Successfully uploaded and synced note: ${note.title}',\n+              );\n+            } else {\n+              debugPrint(\n+                'NotesController: Failed to upload note ${note.title} - no Drive ID returned',\n+              );\n+            }\n           } catch (e) {\n-            debugPrint('NotesController: Error uploading note ${note.title} - $e');\n+            debugPrint(\n+              'NotesController: Error uploading note ${note.title} - $e',\n+            );\n             continue;\n           }\n         }\n       }\n"
                },
                {
                    "date": 1744972222208,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,18 +51,12 @@\n             final driveId = await DriveService.instance.createNote(\n               note.title,\n               note.content,\n             );\n-            if (driveId != null) {\n-              await LocalDatabase.instance.markNoteAsSynced(note.id, driveId);\n-              debugPrint(\n-                'NotesController: Successfully uploaded and synced note: ${note.title}',\n-              );\n-            } else {\n-              debugPrint(\n-                'NotesController: Failed to upload note ${note.title} - no Drive ID returned',\n-              );\n-            }\n+            await LocalDatabase.instance.markNoteAsSynced(note.id, driveId);\n+            debugPrint(\n+              'NotesController: Successfully uploaded and synced note: ${note.title}',\n+            );\n           } catch (e) {\n             debugPrint(\n               'NotesController: Error uploading note ${note.title} - $e',\n             );\n"
                },
                {
                    "date": 1744972368629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -12,82 +12,65 @@\n class NotesController extends AsyncNotifier<List<NoteModel>> {\n   @override\n   Future<List<NoteModel>> build() async {\n     debugPrint('NotesController: Loading notes...');\n-\n+    \n     // Always get local notes first\n     final localNotes = await LocalDatabase.instance.getAllNotes();\n     debugPrint('NotesController: Found ${localNotes.length} local notes');\n+    \n+    try {\n+      // Get unsynced notes before trying to access Drive\n+      final unsyncedNotes = localNotes.where((note) => !note.isSynced).toList();\n+      if (unsyncedNotes.isNotEmpty) {\n+        debugPrint('NotesController: Found ${unsyncedNotes.length} unsynced notes to upload');\n+        for (var note in unsyncedNotes) {\n+          try {\n+            debugPrint('NotesController: Uploading unsynced note: ${note.title}');\n+            final driveId = await DriveService.instance.createNote(note.title, note.content);\n+            await LocalDatabase.instance.markNoteAsSynced(note.id, driveId);\n+            debugPrint('NotesController: Successfully uploaded and synced note: ${note.title}');\n+          } catch (e) {\n+            debugPrint('NotesController: Error uploading note ${note.title} - $e');\n+            continue;\n+          }\n+        }\n+      }\n \n-    try {\n-      // Try to get notes from Drive\n+      // Now get notes from Drive\n       final driveFiles = await DriveService.instance.listRawFiles();\n       debugPrint('NotesController: Found ${driveFiles.length} files in Drive');\n \n       final driveNotes = <NoteModel>[];\n       for (var f in driveFiles) {\n         try {\n           debugPrint('NotesController: Loading content for file ${f.name}');\n           final content = await DriveService.instance.fetchContent(f.id);\n-          driveNotes.add(\n-            NoteModel.fromDrive(id: f.id, name: f.name, content: content),\n-          );\n+          driveNotes.add(NoteModel.fromDrive(id: f.id, name: f.name, content: content));\n         } catch (e) {\n           debugPrint('NotesController: Error loading note ${f.name} - $e');\n           continue;\n         }\n       }\n-\n-      // Upload unsynced local notes to Drive\n-      final unsyncedNotes = localNotes.where((note) => !note.isSynced).toList();\n-      if (unsyncedNotes.isNotEmpty) {\n-        debugPrint(\n-          'NotesController: Found ${unsyncedNotes.length} unsynced notes to upload',\n-        );\n-        for (var note in unsyncedNotes) {\n-          try {\n-            debugPrint(\n-              'NotesController: Uploading unsynced note: ${note.title}',\n-            );\n-            final driveId = await DriveService.instance.createNote(\n-              note.title,\n-              note.content,\n-            );\n-            await LocalDatabase.instance.markNoteAsSynced(note.id, driveId);\n-            debugPrint(\n-              'NotesController: Successfully uploaded and synced note: ${note.title}',\n-            );\n-          } catch (e) {\n-            debugPrint(\n-              'NotesController: Error uploading note ${note.title} - $e',\n-            );\n-            continue;\n-          }\n-        }\n-      }\n-\n+      \n       // Merge notes, prioritizing Drive versions\n       final mergedNotes = <NoteModel>[];\n       final localNoteMap = {for (var note in localNotes) note.id: note};\n-\n+      \n       // Add all Drive notes first\n       for (var driveNote in driveNotes) {\n         mergedNotes.add(driveNote);\n         // Remove from local map to track which notes are only local\n         localNoteMap.remove(driveNote.id);\n       }\n-\n+      \n       // Add remaining local notes that aren't in Drive\n       mergedNotes.addAll(localNoteMap.values);\n-\n-      debugPrint(\n-        'NotesController: Merged ${mergedNotes.length} notes (${driveNotes.length} from Drive, ${localNoteMap.length} local-only)',\n-      );\n+      \n+      debugPrint('NotesController: Merged ${mergedNotes.length} notes (${driveNotes.length} from Drive, ${localNoteMap.length} local-only)');\n       return mergedNotes;\n     } catch (e) {\n-      debugPrint(\n-        'NotesController: Error loading from Drive, using local notes - $e',\n-      );\n+      debugPrint('NotesController: Error loading from Drive, using local notes - $e');\n       return localNotes;\n     }\n   }\n \n"
                },
                {
                    "date": 1744972666146,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,119 @@\n- \n\\ No newline at end of file\n+import 'package:drivenotes/features/notes/data/drive_service.dart';\n+import 'package:drivenotes/features/notes/domain/models/note_model.dart';\n+import 'package:flutter/foundation.dart';\n+import 'package:flutter_riverpod/flutter_riverpod.dart';\n+import 'package:drivenotes/features/notes/data/local_database.dart';\n+\n+final notesControllerProvider =\n+    AsyncNotifierProvider<NotesController, List<NoteModel>>(\n+      NotesController.new,\n+    );\n+\n+class NotesController extends AsyncNotifier<List<NoteModel>> {\n+  @override\n+  Future<List<NoteModel>> build() async {\n+    debugPrint('NotesController: Loading notes...');\n+\n+    // Always get local notes first\n+    final localNotes = await LocalDatabase.instance.getAllNotes();\n+    debugPrint('NotesController: Found ${localNotes.length} local notes');\n+\n+    try {\n+      // Get unsynced notes before trying to access Drive\n+      final unsyncedNotes = localNotes.where((note) => !note.isSynced).toList();\n+      if (unsyncedNotes.isNotEmpty) {\n+        debugPrint(\n+          'NotesController: Found ${unsyncedNotes.length} unsynced notes to upload',\n+        );\n+        for (var note in unsyncedNotes) {\n+          try {\n+            debugPrint(\n+              'NotesController: Uploading unsynced note: ${note.title}',\n+            );\n+            final driveId = await DriveService.instance.createNote(\n+              note.title,\n+              note.content,\n+            );\n+            await LocalDatabase.instance.markNoteAsSynced(note.id, driveId);\n+            debugPrint(\n+              'NotesController: Successfully uploaded and synced note: ${note.title}',\n+            );\n+          } catch (e) {\n+            debugPrint(\n+              'NotesController: Error uploading note ${note.title} - $e',\n+            );\n+            continue;\n+          }\n+        }\n+      }\n+\n+      // Now get notes from Drive\n+      final driveFiles = await DriveService.instance.listRawFiles();\n+      debugPrint('NotesController: Found ${driveFiles.length} files in Drive');\n+\n+      final driveNotes = <NoteModel>[];\n+      for (var f in driveFiles) {\n+        try {\n+          debugPrint('NotesController: Loading content for file ${f.name}');\n+          final content = await DriveService.instance.fetchContent(f.id);\n+          driveNotes.add(\n+            NoteModel.fromDrive(id: f.id, name: f.name, content: content),\n+          );\n+        } catch (e) {\n+          debugPrint('NotesController: Error loading note ${f.name} - $e');\n+          continue;\n+        }\n+      }\n+\n+      // Merge notes, prioritizing Drive versions\n+      final mergedNotes = <NoteModel>[];\n+      final localNoteMap = {for (var note in localNotes) note.id: note};\n+\n+      // Add all Drive notes first\n+      for (var driveNote in driveNotes) {\n+        mergedNotes.add(driveNote);\n+        // Remove from local map to track which notes are only local\n+        localNoteMap.remove(driveNote.id);\n+      }\n+\n+      // Add remaining local notes that aren't in Drive\n+      mergedNotes.addAll(localNoteMap.values);\n+\n+      debugPrint(\n+        'NotesController: Merged ${mergedNotes.length} notes (${driveNotes.length} from Drive, ${localNoteMap.length} local-only)',\n+      );\n+      return mergedNotes;\n+    } catch (e) {\n+      debugPrint(\n+        'NotesController: Error loading from Drive, using local notes - $e',\n+      );\n+      return localNotes;\n+    }\n+  }\n+\n+  Future<void> delete(String id) async {\n+    debugPrint('NotesController: Deleting note $id');\n+    state = const AsyncValue.loading();\n+    try {\n+      // Delete from Drive first\n+      try {\n+        await DriveService.instance.deleteNote(id);\n+        debugPrint('NotesController: Deleted from Drive successfully');\n+      } catch (e) {\n+        debugPrint('NotesController: Error deleting from Drive - $e');\n+        // Continue with local deletion even if Drive fails\n+      }\n+\n+      // Always delete locally\n+      await LocalDatabase.instance.deleteNote(id);\n+      debugPrint('NotesController: Deleted from local DB successfully');\n+\n+      // Update state\n+      final remain = state.value!.where((n) => n.id != id).toList();\n+      state = AsyncValue.data(remain);\n+    } catch (e, st) {\n+      debugPrint('NotesController: Error deleting note - $e');\n+      state = AsyncValue.error(e, st);\n+    }\n+  }\n+}\n"
                },
                {
                    "date": 1744972848927,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -94,23 +94,30 @@\n   Future<void> delete(String id) async {\n     debugPrint('NotesController: Deleting note $id');\n     state = const AsyncValue.loading();\n     try {\n-      // Delete from Drive first\n-      try {\n-        await DriveService.instance.deleteNote(id);\n-        debugPrint('NotesController: Deleted from Drive successfully');\n-      } catch (e) {\n-        debugPrint('NotesController: Error deleting from Drive - $e');\n-        // Continue with local deletion even if Drive fails\n+      // Get the note first to check if it's synced\n+      final note = state.value?.firstWhere((n) => n.id == id);\n+      \n+      // Delete from Drive if the note is synced\n+      if (note?.isSynced == true) {\n+        try {\n+          debugPrint('NotesController: Deleting from Drive - ID: $id');\n+          await DriveService.instance.deleteNote(id);\n+          debugPrint('NotesController: Deleted from Drive successfully');\n+        } catch (e) {\n+          debugPrint('NotesController: Error deleting from Drive - $e');\n+          // Continue with local deletion even if Drive fails\n+        }\n       }\n \n       // Always delete locally\n+      debugPrint('NotesController: Deleting from local DB - ID: $id');\n       await LocalDatabase.instance.deleteNote(id);\n       debugPrint('NotesController: Deleted from local DB successfully');\n \n-      // Update state\n-      final remain = state.value!.where((n) => n.id != id).toList();\n+      // Update state by removing the deleted note\n+      final remain = state.value?.where((n) => n.id != id).toList() ?? [];\n       state = AsyncValue.data(remain);\n     } catch (e, st) {\n       debugPrint('NotesController: Error deleting note - $e');\n       state = AsyncValue.error(e, st);\n"
                }
            ],
            "date": 1744897162364,
            "name": "Commit-0",
            "content": "flutter pub add flutter_riverpod google_sign_in googleapis googleapis_auth http flutter_secure_storage dio go_router json_serializable firebase_core firebase_auth\r\n"
        }
    ]
}
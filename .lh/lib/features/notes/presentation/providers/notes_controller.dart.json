{
    "sourceFile": "lib/features/notes/presentation/providers/notes_controller.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1744972554699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1744972667390,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n-import 'package:drivenotes/features/notes/data/datasources/drive_service.dart';\n-import 'package:drivenotes/features/notes/domain/entities/note_model.dart';\n+import 'package:drivenotes/features/notes/data/drive_service.dart';\n+import 'package:drivenotes/features/notes/domain/models/note_model.dart';\n import 'package:flutter/foundation.dart';\n import 'package:flutter_riverpod/flutter_riverpod.dart';\n-import 'package:drivenotes/features/notes/data/datasources/local_database.dart';\n+import 'package:drivenotes/features/notes/data/local_database.dart';\n \n final notesControllerProvider =\n     AsyncNotifierProvider<NotesController, List<NoteModel>>(\n       NotesController.new,\n"
                }
            ],
            "date": 1744972554699,
            "name": "Commit-0",
            "content": "import 'package:drivenotes/features/notes/data/datasources/drive_service.dart';\nimport 'package:drivenotes/features/notes/domain/entities/note_model.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter_riverpod/flutter_riverpod.dart';\nimport 'package:drivenotes/features/notes/data/datasources/local_database.dart';\n\nfinal notesControllerProvider =\n    AsyncNotifierProvider<NotesController, List<NoteModel>>(\n      NotesController.new,\n    );\n\nclass NotesController extends AsyncNotifier<List<NoteModel>> {\n  @override\n  Future<List<NoteModel>> build() async {\n    debugPrint('NotesController: Loading notes...');\n\n    // Always get local notes first\n    final localNotes = await LocalDatabase.instance.getAllNotes();\n    debugPrint('NotesController: Found ${localNotes.length} local notes');\n\n    try {\n      // Get unsynced notes before trying to access Drive\n      final unsyncedNotes = localNotes.where((note) => !note.isSynced).toList();\n      if (unsyncedNotes.isNotEmpty) {\n        debugPrint(\n          'NotesController: Found ${unsyncedNotes.length} unsynced notes to upload',\n        );\n        for (var note in unsyncedNotes) {\n          try {\n            debugPrint(\n              'NotesController: Uploading unsynced note: ${note.title}',\n            );\n            final driveId = await DriveService.instance.createNote(\n              note.title,\n              note.content,\n            );\n            await LocalDatabase.instance.markNoteAsSynced(note.id, driveId);\n            debugPrint(\n              'NotesController: Successfully uploaded and synced note: ${note.title}',\n            );\n          } catch (e) {\n            debugPrint(\n              'NotesController: Error uploading note ${note.title} - $e',\n            );\n            continue;\n          }\n        }\n      }\n\n      // Now get notes from Drive\n      final driveFiles = await DriveService.instance.listRawFiles();\n      debugPrint('NotesController: Found ${driveFiles.length} files in Drive');\n\n      final driveNotes = <NoteModel>[];\n      for (var f in driveFiles) {\n        try {\n          debugPrint('NotesController: Loading content for file ${f.name}');\n          final content = await DriveService.instance.fetchContent(f.id);\n          driveNotes.add(\n            NoteModel.fromDrive(id: f.id, name: f.name, content: content),\n          );\n        } catch (e) {\n          debugPrint('NotesController: Error loading note ${f.name} - $e');\n          continue;\n        }\n      }\n\n      // Merge notes, prioritizing Drive versions\n      final mergedNotes = <NoteModel>[];\n      final localNoteMap = {for (var note in localNotes) note.id: note};\n\n      // Add all Drive notes first\n      for (var driveNote in driveNotes) {\n        mergedNotes.add(driveNote);\n        // Remove from local map to track which notes are only local\n        localNoteMap.remove(driveNote.id);\n      }\n\n      // Add remaining local notes that aren't in Drive\n      mergedNotes.addAll(localNoteMap.values);\n\n      debugPrint(\n        'NotesController: Merged ${mergedNotes.length} notes (${driveNotes.length} from Drive, ${localNoteMap.length} local-only)',\n      );\n      return mergedNotes;\n    } catch (e) {\n      debugPrint(\n        'NotesController: Error loading from Drive, using local notes - $e',\n      );\n      return localNotes;\n    }\n  }\n\n  Future<void> delete(String id) async {\n    debugPrint('NotesController: Deleting note $id');\n    state = const AsyncValue.loading();\n    try {\n      // Delete from Drive first\n      try {\n        await DriveService.instance.deleteNote(id);\n        debugPrint('NotesController: Deleted from Drive successfully');\n      } catch (e) {\n        debugPrint('NotesController: Error deleting from Drive - $e');\n        // Continue with local deletion even if Drive fails\n      }\n\n      // Always delete locally\n      await LocalDatabase.instance.deleteNote(id);\n      debugPrint('NotesController: Deleted from local DB successfully');\n\n      // Update state\n      final remain = state.value!.where((n) => n.id != id).toList();\n      state = AsyncValue.data(remain);\n    } catch (e, st) {\n      debugPrint('NotesController: Error deleting note - $e');\n      state = AsyncValue.error(e, st);\n    }\n  }\n}\n"
        }
    ]
}